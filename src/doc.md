-------------------------------------------------------------------------------
Math
-------------------------------------------------------------------------------

DotProduct - скалярное произведение векторов
	
	DotProduct(a,b) = DotProduct(b,a)

		> 0 - вектора направлены в одну сторону
		= 0 - вектора перпендикулярны (90 градусов)
		< 0 - вектора направлены противоположно
		= 1 - паралельны?
		= 0.7 - 45 градусов?
			пример - Dot(EnemyPos - PlayerPos, Forward) > 0 - враг перед нами
			или освещение по ламберту - max(dot(Light.Direction, NormalVector)), 0.0);
				идея такая - если свет светит прямо на поверхность то вектор направления света паралелен нормали поверхности - dot вернет 1.
	DotProduct(na,nb) = cos(angle_rad_to_ab) - скалярное произведение нормализованных векторов равно косинусу угла между ними

CrossProduct - векторное произведение векторов.
	Может быть только в 3д
	Результат - получается вектор перпендикулярный двум другим. Пример - оси xyz - векторным произведением векторов x и y будет вектор z
	
	CrossProduct(a,b) != CrossProduct(b,a)

	Примеры применения
		площадь треугольника - float area = Length(Cross(u,v)) / 2;
		Нормаль треугольника - vec3 normal = Normalize(Cross(C-A, B-A));

		Коррекция движения при коллизиях (скольжение вдоль стены)
			dir - тек вектор движения
			normal - нормаль поверхности
			vec3 tempVec = cross(dir, normal);
			vec3 newDir = cross(tempVec, normal);

			(но можно еще быстрее через нахождение отраженного вектора
				vec3 newDir = dir - normal*dir(dir, normal);

-------------------------------------------------------------------------------
Разное
-------------------------------------------------------------------------------
meshData[0].vertices = {
	{ {-0.5f, 0.5f, 0.5f}, { 0.0f, 0.0f,-1.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f} },
	{ { 0.5f, 0.5f, 0.5f}, { 0.0f, 0.0f,-1.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 0.0f} },
	{ { 0.5f,-0.5f, 0.5f}, { 0.0f, 0.0f,-1.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 1.0f} },
	{ {-0.5f,-0.5f, 0.5f}, { 0.0f, 0.0f,-1.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f} },// front

	{ { 0.5f, 0.5f,-0.5f}, { 0.0f, 0.0f, 1.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f} },
	{ {-0.5f, 0.5f,-0.5f}, { 0.0f, 0.0f, 1.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 0.0f} },
	{ {-0.5f,-0.5f,-0.5f}, { 0.0f, 0.0f, 1.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 1.0f} },
	{ { 0.5f,-0.5f,-0.5f}, { 0.0f, 0.0f, 1.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f} },// back

	{ {-0.5f, 0.5f,-0.5f}, { 0.0f, 1.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f} },
	{ { 0.5f, 0.5f,-0.5f}, { 0.0f, 1.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 0.0f} },
	{ { 0.5f, 0.5f, 0.5f}, { 0.0f, 1.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 1.0f} },
	{ {-0.5f, 0.5f, 0.5f}, { 0.0f, 1.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f} },// top

	{ { 0.5f,-0.5f,-0.5f}, { 0.0f,-1.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f} },
	{ {-0.5f,-0.5f,-0.5f}, { 0.0f,-1.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 0.0f} },
	{ {-0.5f,-0.5f, 0.5f}, { 0.0f,-1.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 1.0f} },
	{ { 0.5f,-0.5f, 0.5f}, { 0.0f,-1.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f} },// bottom

	{ {-0.5f, 0.5f,-0.5f}, {-1.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f} },
	{ {-0.5f, 0.5f, 0.5f}, {-1.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 0.0f} },
	{ {-0.5f,-0.5f, 0.5f}, {-1.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 1.0f} },
	{ {-0.5f,-0.5f,-0.5f}, {-1.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f} },// left

	{ { 0.5f, 0.5f, 0.5f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f} },
	{ { 0.5f, 0.5f,-0.5f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 0.0f} },
	{ { 0.5f,-0.5f,-0.5f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {1.0f, 1.0f} },
	{ { 0.5f,-0.5f, 0.5f}, {1.0f, 0.0f, 0.0f}, {1.0f, 1.0f, 1.0f}, {0.0f, 1.0f} },// right
};

meshData[0].indices = {
	0, 3, 1,  1, 3, 2, // front
	4, 7, 5,  5, 7, 6, // back
	8,11, 9,  9,11,10, // top
	12,15,13, 13,15,14, // bottom
	16,19,17, 17,19,18, // left
	20,23,21, 21,23,22  // right
};