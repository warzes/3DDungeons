#include "MicroAdvance.h"
#include "MicroEngine.h"
//=============================================================================
// Header
//=============================================================================
#if defined(_MSC_VER)
#	pragma warning(push)
#endif // _MSC_VER

#include <map>
#include <unordered_map>

#if defined(_MSC_VER)
#	pragma warning(pop)
#endif // _MSC_VER
//-----------------------------------------------------------------------------
//=============================================================================
// Global var
//=============================================================================
//-----------------------------------------------------------------------------
std::unordered_map<std::string, Texture2D> FileTextures2D;
std::unordered_map<std::string, Model> FileModel;
//-----------------------------------------------------------------------------
//=============================================================================
// ResourceCacheSystem
//=============================================================================
//-----------------------------------------------------------------------------
ShaderProgram* ResourceCacheSystem::LoadShaderProgram(const char* fileName)
{
	assert(false);
	return nullptr;
}
//-----------------------------------------------------------------------------
Texture2D* ResourceCacheSystem::LoadTexture2D(const char* fileName, const Texture2DInfo& textureInfo)
{
	auto it = FileTextures2D.find(fileName);
	if( it != FileTextures2D.end() )
	{
		return &it->second;
	}
	else
	{
		LogPrint("Load texture: " + std::string(fileName));

		Texture2D texture;
		if( !texture.Create(fileName, textureInfo) || !texture.IsValid() )
			return nullptr;

		FileTextures2D[fileName] = texture;
		return &FileTextures2D[fileName];
	}
}
//-----------------------------------------------------------------------------
Model* ResourceCacheSystem::LoadModel(const char* fileName)
{
	auto it = FileModel.find(fileName);
	if (it != FileModel.end())
	{
		return &it->second;
	}
	else
	{
		LogPrint("Load model: " + std::string(fileName));

		Model model;
		if (!model.Create(fileName) || !model.IsValid())
			return nullptr;

		FileModel[fileName] = model;
		return &FileModel[fileName];
	}
}
//-----------------------------------------------------------------------------
bool ResourceCacheSystem::IsLoad(const ShaderProgram& shader)
{
	return false;
}
//-----------------------------------------------------------------------------
bool ResourceCacheSystem::IsLoad(const Texture2D& texture)
{
	for (auto it = FileTextures2D.begin(); it != FileTextures2D.end(); ++it)
	{
		if (texture == it->second)
			return true;
	}
	return false;
}
//-----------------------------------------------------------------------------
void ResourceCacheSystem::Clear()
{
	for( auto it = FileTextures2D.begin(); it != FileTextures2D.end(); ++it )
		it->second.Destroy();
	FileTextures2D.clear();

	for( auto it = FileModel.begin(); it != FileModel.end(); ++it )
		it->second.Destroy();
	FileModel.clear();
}
//-----------------------------------------------------------------------------
//=============================================================================
// Debug Draw
//=============================================================================
//-----------------------------------------------------------------------------
ShaderProgram shaderProgram;
int MatrixID;
int ColorID;
GLuint vao, vbo;
std::map<unsigned, std::vector<Vector3>> Points;
std::map<unsigned, std::vector<Vector3>> Lines;
//-----------------------------------------------------------------------------
// TODO: можно оптимизировать, если хранить цвет в вершине, тогда не нужно использовать мап, можно использовать массив который только растет (а сбрасывается только счетчик). но займет больше памяти. хотя и н сильно
//-----------------------------------------------------------------------------
void drawGround(float scale)
{ // 10x10
	// outer
	for (float i = -scale, c = 0; c <= 20; c += 20, i += c * (scale / 10))
	{
		DebugDraw::DrawLine({ -scale, 0, i }, { scale, 0, i }, WHITE); // horiz
		DebugDraw::DrawLine({ i, 0, -scale }, { i, 0, +scale }, WHITE); // vert
	}
	// inner
	for (float i = -scale + scale / 10, c = 1; c < 20; ++c, i += (scale / 10))
	{
		DebugDraw::DrawLine({ -scale, 0, i }, { +scale, 0, i }, GRAY); // horiz
		DebugDraw::DrawLine({ i, 0, -scale }, { i, 0, +scale }, GRAY); // vert
	}
}
//-----------------------------------------------------------------------------
void DrawConeLowres(const Vector3& center, const Vector3& top, float radius, unsigned rgb)
{
	Vector3 diff3 = top - center;
	DebugDraw::DrawPrism(center, radius ? radius : 1, diff3.GetLength(), diff3.GetNormalize(), 3, rgb);
}
//-----------------------------------------------------------------------------
void DrawCircleWithOrientation(const Vector3& center, Vector3 dir, float radius, unsigned rgb)
{
	// we'll skip 3 segments out of 32. 1.5 per half circle.
	int segments = 32, skip = 3, drawn_segments = segments - skip;

	//  dir = norm3(dir);
	Vector3 right = CrossProduct(dir, { 0.0f, 1.0f, 0.0f });
	Vector3 up = CrossProduct(dir, right);
	right = CrossProduct(dir, up);

	Vector3 point, lastPoint;
	dir = dir * radius;
	right = right * radius;
	//lastPoint = (center + dir);

	{
		const float radians = (PI * 2) * (0 + skip / 2.f) / segments;
		Vector3 vs = right * sinf(radians);
		Vector3 vc = dir * cosf(radians);
		lastPoint = center + vs;
		lastPoint = lastPoint + vc;
	}

	DebugDraw::DrawLine(lastPoint, (center + (dir * radius * 1.25)), rgb);

	for (int i = 0; i <= drawn_segments; ++i)
	{
		const float radians = (PI * 2) * (i + skip / 2.f) / segments;

		Vector3 vs = (right * sinf(radians));
		Vector3 vc = (dir * cosf(radians));

		point = (center + vs);
		point = (point + vc);

		DebugDraw::DrawLine(lastPoint, point, rgb);
		lastPoint = point;
	}

	DebugDraw::DrawLine(lastPoint, (center + (dir * radius * 1.25)), rgb);
}
//-----------------------------------------------------------------------------

inline void  orthoVec(Vector3* left, Vector3* up, Vector3 v)
{
#if 0
	if ((v.z * v.z) > (0.7f * 0.7f)) {
		float sqrlen = v.y * v.y + v.z * v.z;
		float invlen = 1.f / sqrtf(sqrlen);
		*up = Vector3(0, v.z * invlen, -v.y * invlen);
		*left = Vector3(sqrlen * invlen, -v.x * up->z, v.x * up->y);
	}
	else {
		float sqrlen = v.x * v.x + v.y * v.y;
		float invlen = 1.f / sqrtf(sqrlen);
		*left = Vector3(-v.y * invlen, v.x * invlen, 0);
		*up = Vector3(-v.z * left->y, v.z * left->x, sqrlen * invlen);
	}
#else
	* left = (v.z * v.z) < (v.x * v.x) ? Vector3(v.y, -v.x, 0) : Vector3(0, -v.z, v.y);
	*up = CrossProduct(*left, v);
#endif
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawPoint(const Vector3& from, unsigned rgb)
{
	Points[rgb].push_back(from);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawLine(const Vector3& from, const Vector3& to, unsigned rgb)
{
	Lines[rgb].push_back(from);
	Lines[rgb].push_back(to);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawLineDashed(Vector3 from, Vector3 to, unsigned rgb)
{
	Vector3 dist = (to - from);
	Vector3 unit = dist.GetNormalize();
	for (float len = 0, mag = dist.GetLength() / 2; len < mag; ++len)
	{
		to = (from + unit);
		DrawLine(from, to, rgb);
		from = (to + unit);
	}
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawAxis(float units)
{
	DrawLine(Vector3(0, 0, 0), Vector3(units, 0, 0), RED);
	DrawLineDashed(Vector3(0, 0, 0), Vector3(-units, 0, 0), RED);

	DrawLine(Vector3(0, 0, 0), Vector3(0, units, 0), GREEN);
	DrawLineDashed(Vector3(0, 0, 0), Vector3(0, -units, 0), GREEN);

	DrawLine(Vector3(0, 0, 0), Vector3(0, 0, units), BLUE);
	DrawLineDashed(Vector3(0, 0, 0), Vector3(0, 0, -units), BLUE);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawGround(float scale)
{
	if (scale)
	{
		drawGround(scale);
	}
	else
	{
		drawGround(100);
		drawGround(10);
		drawGround(1);
		drawGround(0.1);
		drawGround(0.01);
	}
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawGrid(float scale)
{
	DrawGround(scale);
	DrawAxis(scale ? scale : 100.0f);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawTriangle(const Vector3& pa, const Vector3& pb, const Vector3& pc, unsigned rgb)
{
	DrawLine(pa, pb, rgb);
	DrawLine(pa, pc, rgb);
	DrawLine(pb, pc, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawArrow(const Vector3& begin, const Vector3& end, unsigned rgb)
{
	Vector3 diff = (end - begin);
	float len = diff.GetLength(), stick_len = len * 2 / 3;

	DrawLine(begin, end, rgb);
	DrawConeLowres((begin + (diff.GetNormalize() * stick_len)), end, len / 6, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawBounds(const Vector3 points[8], unsigned rgb)
{
	for (int i = 0; i < 4; ++i)
	{
		DrawLine(points[i], points[(i + 1) & 3], rgb);
		DrawLine(points[i], points[4 + i], rgb);
		DrawLine(points[4 + i], points[4 + ((i + 1) & 3)], rgb);
	}
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawBox(const Vector3& c, const Vector3& extents, unsigned rgb)
{
	Vector3 points[8], whd = (extents * 0.5f);
#define DD_BOX_V(v, op1, op2, op3) (v).x = c.x op1 whd.x; (v).y = c.y op2 whd.y; (v).z = c.z op3 whd.z
	DD_BOX_V(points[0], -, +, +);
	DD_BOX_V(points[1], -, +, -);
	DD_BOX_V(points[2], +, +, -);
	DD_BOX_V(points[3], +, +, +);
	DD_BOX_V(points[4], -, -, +);
	DD_BOX_V(points[5], -, -, -);
	DD_BOX_V(points[6], +, -, -);
	DD_BOX_V(points[7], +, -, +);
#undef DD_BOX_V
	DrawBounds(points, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawCube(const Vector3& center, float radius, unsigned rgb)
{
	// draw_prism(center, 1, -1, vec3(0,1,0), 4);
	float half = radius * 0.5f;
	Vector3 l = Vector3(center.x - half, center.y + half, center.z - half); // left-top-far
	Vector3 r = Vector3(center.x + half, center.y - half, center.z + half); // right-bottom-near

	DrawLine(l, Vector3(r.x, l.y, l.z), rgb);
	DrawLine(Vector3(r.x, l.y, l.z), Vector3(r.x, l.y, r.z), rgb);
	DrawLine(Vector3(r.x, l.y, r.z), Vector3(l.x, l.y, r.z), rgb);
	DrawLine(Vector3(l.x, l.y, r.z), l, rgb);
	DrawLine(l, Vector3(l.x, r.y, l.z), rgb);

	DrawLine(r, Vector3(l.x, r.y, r.z), rgb);
	DrawLine(Vector3(l.x, r.y, r.z), Vector3(l.x, r.y, l.z), rgb);
	DrawLine(Vector3(l.x, r.y, l.z), Vector3(r.x, r.y, l.z), rgb);
	DrawLine(Vector3(r.x, r.y, l.z), r, rgb);
	DrawLine(r, Vector3(r.x, l.y, r.z), rgb);

	DrawLine(Vector3(l.x, l.y, r.z), Vector3(l.x, r.y, r.z), rgb);
	DrawLine(Vector3(r.x, l.y, l.z), Vector3(r.x, r.y, l.z), rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawPlane(const Vector3& p, const Vector3& n, float scale, unsigned rgb)
{
	// if n is too similar to up vector, use right. else use up vector
	Vector3 v1 = CrossProduct(n, DotProduct(n, Vector3(0, 1, 0)) > 0.8f ? Vector3(1, 0, 0) : Vector3(0, 1, 0));
	Vector3 v2 = CrossProduct(n, v1);

	// draw axis
	DrawLine(p, (p + n), rgb);
	DrawLine(p, (p + v1), rgb);
	DrawLine(p, (p + v2), rgb);

	// get plane coords
	v1 = (v1 * scale);
	v2 = (v2 *  scale);
	Vector3 p1 = ((p + v1) + v2);
	Vector3 p2 = ((p - v1) + v2);
	Vector3 p3 = ((p - v1) - v2);
	Vector3 p4 = ((p + v1) - v2);

	// draw plane
	DrawLine(p1, p2, rgb);
	DrawLine(p2, p3, rgb);
	DrawLine(p3, p4, rgb);
	DrawLine(p4, p1, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawSphere(const Vector3& center, float radius, unsigned rgb)
{
	float lod = 6, yp = -radius, rp = 0, y, r, x, z;
	for (int j = 1; j <= lod / 2; ++j, yp = y, rp = r)
	{
		y = j * 2.f / (lod / 2) - 1;
		r = cosf(y * 3.14159f / 2) * radius;
		y = sinf(y * 3.14159f / 2) * radius;

		float xp = 1, zp = 0;
		for (int i = 1; i <= lod; ++i, xp = x, zp = z)
		{
			x = 3.14159f * 2 * i / lod;
			z = sinf(x);
			x = cosf(x);

			Vector3 a1 = (center + Vector3(xp * rp, yp, zp * rp));
			Vector3 b1 = (center + Vector3(xp * r, y, zp * r));
			Vector3 c1 = (center + Vector3(x * r, y, z * r));

			DrawLine(a1, b1, rgb);
			DrawLine(b1, c1, rgb);
			DrawLine(c1, a1, rgb);

			Vector3 a2 = (center + Vector3(xp * rp, yp, zp * rp));
			Vector3 b2 = (center + Vector3(x * r, y, z * r));
			Vector3 c2 = (center + Vector3(x * rp, yp, z * rp));

			DrawLine(a2, b2, rgb);
			DrawLine(b2, c2, rgb);
			DrawLine(c2, a2, rgb);
		}
	}
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawCapsule(const Vector3& from, const Vector3& to, float r, unsigned rgb)
{
	/* calculate axis */
	Vector3 up, right, forward;
	forward = (to - from);
	forward = forward.GetNormalize();
	orthoVec(&right, &up, forward);

	/* calculate first two cone verts (buttom + top) */
	Vector3 lastf, lastt;
	lastf = (up * r);
	lastt = (to + lastf);
	lastf = (from + lastf);

	/* step along circle outline and draw lines */
	enum { step_size = 20 };
	for (int i = step_size; i <= 360; i += step_size)
	{
		/* calculate current rotation */
		Vector3 ax = (right * sinf(i * DEG2RAD));
		Vector3 ay = (up * cosf(i * DEG2RAD));

		/* calculate current vertices on cone */
		Vector3 tmp = (ax + ay);
		Vector3 pf = (tmp * r);
		Vector3 pt = (tmp * r);

		pf = (pf + from);
		pt = (pt + to);

		/* draw cone vertices */
		DrawLine(lastf, pf, rgb);
		DrawLine(lastt, pt, rgb);
		DrawLine(pf, pt, rgb);

		lastf = pf;
		lastt = pt;

		/* calculate first top sphere vert */
		Vector3 prevt = (tmp * r);
		Vector3 prevf = (prevt + from);
		prevt = (prevt + to);

		/* sphere (two half spheres )*/
		for (int j = 1; j < 180 / step_size; j++)
		{
			/* angles */
			float ta = j * step_size;
			float fa = 360 - (j * step_size);

			/* top half-sphere */
			ax = (forward * sinf(ta * DEG2RAD));
			ay = (tmp * cosf(ta * DEG2RAD));

			Vector3 t = (ax + ay);
			pf = (t * r);
			pf = (pf + to);
			DrawLine(pf, prevt, rgb);
			prevt = pf;

			/* bottom half-sphere */
			ax = (forward * sinf(fa * DEG2RAD));
			ay = (tmp * cosf(fa * DEG2RAD));

			t = (ax + ay);
			pf = (t * r);
			pf = (pf + from);
			DrawLine(pf, prevf, rgb);
			prevf = pf;
		}
	}
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawDiamond(const Vector3& from, const Vector3& to, float size, unsigned rgb)
{

	class poly // TODO: удалить?
	{
	public:
		std::vector<Vector3> verts;
		int cnt = 0;

		static poly Pyramid(const Vector3& from, const Vector3& to, float size)
		{
			/* calculate axis */
			Vector3 up, right, forward = (to - from).GetNormalize();
			orthoVec(&right, &up, forward);

			/* calculate extend */
			Vector3 xext = (right * size);
			Vector3 yext = (up * size);
			Vector3 nxext = (right * -size);
			Vector3 nyext = (up * -size);

			/* calculate base vertices */
			poly p;
			p.verts = {
				((from + xext) + yext), /*a*/
				((from + xext) + nyext), /*b*/
				((from + nxext) + nyext), /*c*/
				((from + nxext) + yext), /*d*/
				to, /*r*/
				{} // empty
			};
			p.cnt = 5; /*+1 for diamond case*/ // array_resize(p.verts, 5+1); p.cnt = 5;

			return p;
		}

		static poly Diamond(const Vector3& from, const Vector3& to, float size)
		{
			Vector3 mid = (from + ((to - from) * 0.5f));
			poly p = Pyramid(mid, to, size);
			p.verts[5] = from; p.cnt = 6;
			return p;
		}
	};


	poly p = poly::Diamond(from, to, size);
	Vector3* dmd = p.verts.data();

	Vector3* a = dmd + 0;
	Vector3* b = dmd + 1;
	Vector3* c = dmd + 2;
	Vector3* d = dmd + 3;
	Vector3* t = dmd + 4;
	Vector3* f = dmd + 5;

	/* draw vertices */
	DrawLine(*a, *b, rgb);
	DrawLine(*b, *c, rgb);
	DrawLine(*c, *d, rgb);
	DrawLine(*d, *a, rgb);

	/* draw roof */
	DrawLine(*a, *t, rgb);
	DrawLine(*b, *t, rgb);
	DrawLine(*c, *t, rgb);
	DrawLine(*d, *t, rgb);

	/* draw floor */
	DrawLine(*a, *f, rgb);
	DrawLine(*b, *f, rgb);
	DrawLine(*c, *f, rgb);
	DrawLine(*d, *f, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawPyramid(const Vector3& center, float height, int segments, unsigned rgb)
{
	DrawPrism(center, 1, height, Vector3(0, 1, 0), segments, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawPrism(const Vector3& center, float radius, float height, const Vector3& normal, int segments, unsigned rgb)
{
	Vector3 left = Vector3{ 0 }, up = Vector3{ 0 };
	orthoVec(&left, &up, normal);

	Vector3 point, lastPoint;
	up = (up * radius);
	left = (left * radius);
	lastPoint = (center + up);
	Vector3 pivot = (center + (normal * height));

	for (int i = 1; i <= segments; ++i)
	{
		const float radians = (PI * 2) * i / segments;

		Vector3 vs = (left * sinf(radians));
		Vector3 vc = (up * cosf(radians));

		point = (center + vs);
		point = (point + vc);

		DrawLine(lastPoint, point, rgb);
		if (height > 0)
			DrawLine(point, pivot, rgb);
		else if (height < 0)
		{
			DrawLine(point, (point + (normal * -height)), rgb);
		}
		lastPoint = point;
	}

	if (height < 0)
		DrawPrism((center + (normal * -height)), radius, 0, normal, segments, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawSquare(const Vector3& pos, float radius, unsigned rgb)
{
	DrawPrism(pos, radius, 0, Vector3(0, 1, 0), 4, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawCylinder(const Vector3& center, float height, int segments, unsigned rgb)
{
	DrawPrism(center, 1, -height, Vector3(0, 1, 0), segments, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawPentagon(const Vector3& pos, float radius, unsigned rgb)
{
	DrawPrism(pos, radius, 0, Vector3(0, 1, 0), 5, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawHexagon(const Vector3& pos, float radius, unsigned rgb)
{
	DrawPrism(pos, radius, 0, Vector3(0, 1, 0), 6, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawCone(const Vector3& center, const Vector3& top, float radius, unsigned rgb)
{
	Vector3 diff3 = (top - center);
	DrawPrism(center, radius ? radius : 1, diff3.GetLength(), diff3.GetNormalize(), 24, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawCircle(const Vector3& pos, const Vector3& n, float radius, unsigned rgb)
{
	DrawPrism(pos, radius, 0, n, 32, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawAABB(const Vector3& minbb, const Vector3& maxbb, unsigned rgb)
{
	Vector3 points[8], bb[2] = { minbb, maxbb };
	for (int i = 0; i < 8; ++i)
	{
		points[i].x = bb[(i ^ (i >> 1)) & 1].x;
		points[i].y = bb[(i >> 1) & 1].y;
		points[i].z = bb[(i >> 2) & 1].z;
	}
	DrawBounds/*_corners*/(points, rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawPosition(const Vector3& pos, float radius)
{
	DrawPositionDir(pos, Vector3(0, 0, 0), radius);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawPositionDir(const Vector3& position, const Vector3& direction, float radius)
{
	// idea from http://www.cs.caltech.edu/~keenan/m3drv.pdf and flotilla game UI

	Vector3 ground = Vector3(position.x, 0, position.z);
	unsigned clr = position.y < 0 ? PINK/*ORANGE*/ : CYAN;

	DrawPoint(ground, clr);
	DrawPoint(position, clr);
	(position.y < 0 ? DrawLineDashed(ground, position, clr) : DrawLine(ground, position, clr));

	Vector3 n = direction.GetNormalize(), up = Vector3(0, 1, 0);
	for (int i = 0; i < 10 && i <= fabs(position.y); ++i)
	{
		if (i < 2 && direction.GetLength())
			DrawCircleWithOrientation(ground, n, radius, clr);
		else
			DrawCircle(ground, up, radius, clr);
		radius *= 0.9f;
	}
}//-----------------------------------------------------------------------------

void DebugDraw::DrawNormal(const Vector3& pos, const Vector3& n)
{
	DrawLine(pos, (pos + n.GetNormalize()), YELLOW);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawBone(const Vector3& center, const Vector3& end, unsigned rgb)
{
	Vector3 diff3 = (end - center);
	float len = diff3.GetLength(), len10 = len / 10;
	DrawPrism(center, len10, 0, Vector3(1, 0, 0), 24, rgb);
	DrawPrism(center, len10, 0, Vector3(0, 1, 0), 24, rgb);
	DrawPrism(center, len10, 0, Vector3(0, 0, 1), 24, rgb);
	DrawLine(end, (center + Vector3(0, +len10, 0)), rgb);
	DrawLine(end, (center + Vector3(0, -len10, 0)), rgb);
}
//-----------------------------------------------------------------------------
void DebugDraw::DrawBoid(const Vector3& position, Vector3 dir)
{
	dir = dir.GetNormalize();

	// if n is too similar to up vector, use right. else use up vector
	Vector3 v1 = CrossProduct(dir, DotProduct(dir, Vector3(0, 1, 0)) > 0.8f ? Vector3(1, 0, 0) : Vector3(0, 1, 0));
	Vector3 v2 = CrossProduct(dir, v1);
	v1 = CrossProduct(dir, v2);

	uint32_t clr = position.y < 0 ? ORANGE : CYAN;

	Vector3 front = (position + (dir * 1));
	Vector3 back = (position + (dir * -0.25f));
	Vector3 right = (back + (v1 * 0.5f));
	Vector3 left = (back + (v1 * -0.5f));
	DrawLine(front, left, clr);
	DrawLine(left, position, clr);
	DrawLine(position, right, clr);
	DrawLine(right, front, clr);
}
//-----------------------------------------------------------------------------
void DebugDraw::Flush(const Matrix4& ViewProj)
{
	if (Points.empty() && Lines.empty())
		return;

	shaderProgram.Bind();
	shaderProgram.SetUniform(MatrixID, ViewProj);

	// TODO: сделать интерфейс
	VertexArrayBuffer::UnBind();
	glBindVertexArray(vao);
	glBindBuffer(GL_ARRAY_BUFFER, vbo);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vector3), 0);

	//glEnable(GL_DEPTH_TEST);
	//glDepthFunc(GL_LEQUAL);
	//glEnable(GL_PROGRAM_POINT_SIZE); // for GL_POINTS
	//glEnable(GL_LINE_SMOOTH); // for GL_LINES (thin)

	// Draw Points
	{
		//glPointSize(6);
		for (auto& it : Points)
		{
			shaderProgram.SetUniform(ColorID, RGBToVec(it.first));
			const size_t count = it.second.size();
			glBufferData(GL_ARRAY_BUFFER, count * sizeof(Vector3), it.second.data(), GL_STATIC_DRAW);
			glDrawArrays(GL_POINTS, 0, count);
		}
		//glPointSize(1);
	}

	// Draw Lines
	{
		for (auto& it : Lines)
		{
			shaderProgram.SetUniform(ColorID, RGBToVec(it.first));
			const size_t count = it.second.size();
			glBufferData(GL_ARRAY_BUFFER, count * sizeof(Vector3), it.second.data(), GL_STATIC_DRAW);
			glDrawArrays(GL_LINES, 0, count);
		}
	}

	//glEnable(GL_DEPTH_TEST);
	//glDepthFunc(GL_LESS);
	//glDisable(GL_LINE_SMOOTH);
	//glDisable(GL_PROGRAM_POINT_SIZE);
	glBindVertexArray(0);

	Points.clear(); // TODO: надо по другому - без реальной очистки памяти
	Lines.clear(); // TODO: надо по другому - без реальной очистки памяти
}
//-----------------------------------------------------------------------------
bool DebugDraw::Init()
{
	const char* vertexSource = R"(
#version 330 core
layout(location = 0) in vec3 vertexPosition;
uniform mat4 MVP;
uniform vec3 u_color;
out vec3 out_color;
void main()
{
	gl_Position =  MVP * vec4(vertexPosition, 1);
	out_color = u_color;
}
)";

	const char* fragmentSource = R"(
#version 330 core
in vec3 out_color;
out vec4 fragcolor;
void main()
{
	fragcolor = vec4(out_color, 1.0);
}
)";
	if (!shaderProgram.CreateFromMemories(vertexSource, fragmentSource))
		return false;
	MatrixID = shaderProgram.GetUniformLocation("MVP");
	ColorID = shaderProgram.GetUniformLocation("u_color");

	glGenVertexArrays(1, &vao);
	glGenBuffers(1, &vbo);

	return true;
}
//-----------------------------------------------------------------------------
void DebugDraw::Close()
{
	shaderProgram.Destroy();
	glDeleteVertexArrays(1, &vao);
	glDeleteBuffers(1, &vbo);
}
//-----------------------------------------------------------------------------
//=============================================================================
// Debug Text (only ASCII)
//=============================================================================
//-----------------------------------------------------------------------------
uint32_t* debugTextData = nullptr;
size_t debugTextlen = 0;
uint32_t debugTextFG = 0xFFFFFFFF;
uint32_t debugTextBG = 0x00000000;
ShaderProgram debugTextShader;
int debugTextUniformTexture;
int debugTextUniformProjection;
Texture2D debugTextTexture;
VertexArrayBuffer debugTextVao;
VertexBuffer debugTextVbo;
#define DEBUG_FONT_WIDTH  8
#define DEBUG_FONT_HEIGHT 16
#define DEBUG_WIDTH  256
#define DEBUG_HEIGHT 256
#define DEBUG_FONT_DATA_LEN 4096
constexpr uint8_t debugTextFontArray[DEBUG_FONT_DATA_LEN] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7e, 0x81, 0xa5, 0x81, 0x81, 0xbd, 0x99, 0x81, 0x81, 0x7e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7e, 0xff, 0xdb, 0xff, 0xff, 0xc3, 0xe7, 0xff, 0xff, 0x7e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x6c, 0xfe, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0xe7, 0xe7, 0xe7, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x7e, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x1e, 0x0e, 0x1a, 0x32, 0x78, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3f, 0x33, 0x3f, 0x30, 0x30, 0x30, 0x30, 0x70, 0xf0, 0xe0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7f, 0x63, 0x7f, 0x63, 0x63, 0x63, 0x63, 0x67, 0xe7, 0xe6, 0xc0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0xdb, 0x3c, 0xe7, 0x3c, 0xdb, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfe, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x06, 0x0e, 0x1e, 0x3e, 0xfe, 0x3e, 0x1e, 0x0e, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7f, 0xdb, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x7c, 0xc6, 0x60, 0x38, 0x6c, 0xc6, 0xc6, 0x6c, 0x38, 0x0c, 0xc6, 0x7c, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x7e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x6c, 0xfe, 0x6c, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7c, 0x7c, 0xfe, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xfe, 0xfe, 0x7c, 0x7c, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x6c, 0xfe, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x7c, 0xc6, 0xc2, 0xc0, 0x7c, 0x06, 0x06, 0x86, 0xc6, 0x7c, 0x18, 0x18, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xc2, 0xc6, 0x0c, 0x18, 0x30, 0x60, 0xc6, 0x86, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x6c, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xd6, 0xd6, 0xc6, 0xc6, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0x06, 0x06, 0x3c, 0x06, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0c, 0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x0c, 0x0c, 0x1e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0xfc, 0x06, 0x06, 0x06, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x60, 0xc0, 0xc0, 0xfc, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfe, 0xc6, 0x06, 0x06, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x06, 0x06, 0x0c, 0x78, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x0c, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xde, 0xde, 0xde, 0xdc, 0xc0, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x66, 0x66, 0x66, 0x66, 0xfc, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xf8, 0x6c, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfe, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xde, 0xc6, 0xc6, 0x66, 0x3a, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1e, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0xcc, 0x78, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xe6, 0x66, 0x66, 0x6c, 0x78, 0x78, 0x6c, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xf0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xde, 0x7c, 0x0c, 0x0e, 0x00, 0x00,
	0x00, 0x00, 0xfc, 0x66, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7c, 0xc6, 0xc6, 0x60, 0x38, 0x0c, 0x06, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x7e, 0x7e, 0x5a, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xd6, 0xd6, 0xd6, 0xfe, 0xee, 0x6c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0xc6, 0x6c, 0x7c, 0x38, 0x38, 0x7c, 0x6c, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfe, 0xc6, 0x86, 0x0c, 0x18, 0x30, 0x60, 0xc2, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x80, 0xc0, 0xe0, 0x70, 0x38, 0x1c, 0x0e, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00,
	0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xe0, 0x60, 0x60, 0x78, 0x6c, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc0, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1c, 0x0c, 0x0c, 0x3c, 0x6c, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x6c, 0x64, 0x60, 0xf0, 0x60, 0x60, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xcc, 0x78, 0x00,
	0x00, 0x00, 0xe0, 0x60, 0x60, 0x6c, 0x76, 0x66, 0x66, 0x66, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x06, 0x06, 0x00, 0x0e, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3c, 0x00,
	0x00, 0x00, 0xe0, 0x60, 0x60, 0x66, 0x6c, 0x78, 0x78, 0x6c, 0x66, 0xe6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xec, 0xfe, 0xd6, 0xd6, 0xd6, 0xd6, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0x0c, 0x1e, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0x60, 0x60, 0xf0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xc6, 0x60, 0x38, 0x0c, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x10, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xd6, 0xd6, 0xd6, 0xfe, 0x6c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0x6c, 0x38, 0x38, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0xf8, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xcc, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0e, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0e, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3c, 0x66, 0xc2, 0xc0, 0xc0, 0xc0, 0xc2, 0x66, 0x3c, 0x0c, 0x06, 0x7c, 0x00, 0x00,
	0x00, 0x00, 0xcc, 0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0c, 0x18, 0x30, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x38, 0x6c, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xcc, 0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x6c, 0x38, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x3c, 0x66, 0x60, 0x60, 0x66, 0x3c, 0x0c, 0x06, 0x3c, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0x00, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x60, 0x30, 0x18, 0x00, 0x7c, 0xc6, 0xfe, 0xc0, 0xc0, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x3c, 0x66, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x60, 0x30, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xc6, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x38, 0x6c, 0x38, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x30, 0x60, 0x00, 0xfe, 0x66, 0x60, 0x7c, 0x60, 0x60, 0x66, 0xfe, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xcc, 0x76, 0x36, 0x7e, 0xd8, 0xd8, 0x6e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3e, 0x6c, 0xcc, 0xcc, 0xfe, 0xcc, 0xcc, 0xcc, 0xcc, 0xce, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x10, 0x38, 0x6c, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x60, 0x30, 0x18, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x30, 0x78, 0xcc, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x60, 0x30, 0x18, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xc6, 0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7e, 0x06, 0x0c, 0x78, 0x00,
	0x00, 0xc6, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xc6, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x18, 0x3c, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3c, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x6c, 0x64, 0x60, 0xf0, 0x60, 0x60, 0x60, 0x60, 0xe6, 0xfc, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xf8, 0xcc, 0xcc, 0xf8, 0xc4, 0xcc, 0xde, 0xcc, 0xcc, 0xcc, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0e, 0x1b, 0x18, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0x70, 0x00, 0x00,
	0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0c, 0x18, 0x30, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x30, 0x60, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x18, 0x30, 0x60, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x76, 0xdc, 0x00, 0xdc, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
	0x76, 0xdc, 0x00, 0xc6, 0xe6, 0xf6, 0xfe, 0xde, 0xce, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x3c, 0x6c, 0x6c, 0x3e, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x6c, 0x6c, 0x38, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0xc0, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xc0, 0xc0, 0xc2, 0xc6, 0xcc, 0x18, 0x30, 0x60, 0xdc, 0x86, 0x0c, 0x18, 0x3e, 0x00, 0x00,
	0x00, 0xc0, 0xc0, 0xc2, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xce, 0x9e, 0x3e, 0x06, 0x06, 0x00, 0x00,
	0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x3c, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x6c, 0xd8, 0x6c, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xd8, 0x6c, 0x36, 0x6c, 0xd8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44,
	0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa,
	0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77, 0xdd, 0x77,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x36, 0x36, 0x36, 0x36, 0x36, 0xf6, 0x06, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x06, 0xf6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0xf6, 0x06, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0xf7, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xf7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x36, 0x36, 0x36, 0x36, 0x36, 0xf7, 0x00, 0xf7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xff, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0xff, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
	0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f, 0x0f,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0xd8, 0xd8, 0xd8, 0xdc, 0x76, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0xd8, 0xcc, 0xc6, 0xc6, 0xc6, 0xcc, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0xfe, 0xc6, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xfe, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xfe, 0xc6, 0x60, 0x30, 0x18, 0x30, 0x60, 0xc6, 0xfe, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0x70, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xc0, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7e, 0x18, 0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x6c, 0x6c, 0x6c, 0xee, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1e, 0x30, 0x18, 0x0c, 0x3e, 0x66, 0x66, 0x66, 0x66, 0x3c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x7e, 0xdb, 0xdb, 0xdb, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x03, 0x06, 0x7e, 0xdb, 0xdb, 0xf3, 0x7e, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1c, 0x30, 0x60, 0x60, 0x7c, 0x60, 0x60, 0x60, 0x30, 0x1c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7e, 0x18, 0x18, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x30, 0x18, 0x0c, 0x06, 0x0c, 0x18, 0x30, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x0c, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0c, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x0e, 0x1b, 0x1b, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xd8, 0xd8, 0xd8, 0x70, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7e, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xdc, 0x00, 0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x38, 0x6c, 0x6c, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0f, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xec, 0x6c, 0x6c, 0x3c, 0x1c, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xd8, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x70, 0xd8, 0x30, 0x60, 0xc8, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
//-----------------------------------------------------------------------------
void DebugText::SetForeground(const Color& color)
{
	debugTextFG = color.r;
	debugTextFG |= ((uint32_t)color.g) << 8;
	debugTextFG |= ((uint32_t)color.b) << 16;
	debugTextFG |= ((uint32_t)color.a) << 24;
}
//-----------------------------------------------------------------------------
void DebugText::SetBackground(const Color& color)
{
	debugTextBG = color.r;
	debugTextBG |= ((uint32_t)color.g) << 8;
	debugTextBG |= ((uint32_t)color.b) << 16;
	debugTextBG |= ((uint32_t)color.a) << 24;
}
//-----------------------------------------------------------------------------
void DebugText::Print(int x, int y, const char* str)
{
	x *= DEBUG_FONT_WIDTH;
	y *= DEBUG_FONT_HEIGHT;

	const uint8_t* font = debugTextFontArray;
	for( int i = 0; i < strlen(str); i++ )
	{
		size_t c = (str[i] * 16);

		if( c > DEBUG_FONT_DATA_LEN )
			c = 0;

		if( x >= DEBUG_WIDTH * DEBUG_FONT_WIDTH )
		{
			x = 0;
			y += DEBUG_FONT_HEIGHT;
		}
		if( y >= DEBUG_HEIGHT * DEBUG_FONT_HEIGHT )
			y = 0;

		for( int j = 0; j < 16; j++ )
		{
			size_t p = (DEBUG_WIDTH * y) + x;
			p += (DEBUG_WIDTH * j);
			uint8_t byte = font[c + j];

			for( int k = 0; k < 8; k++ )
			{
				int color = (byte >> k) & 0x01;
				if( color )
					debugTextData[p + (8 - k)] = debugTextFG;
				else
					debugTextData[p + (8 - k)] = debugTextBG;
			}
		}

		x += DEBUG_FONT_WIDTH;
	}
}
//-----------------------------------------------------------------------------
void DebugText::Begin()
{
	memset(debugTextData, 0, sizeof(uint32_t) * debugTextlen);
}
//-----------------------------------------------------------------------------
void DebugText::Flush()
{
	Matrix4 ortho = Matrix4::Ortho(0.0f, GetWindowWidth(), GetWindowHeight(), 0.0f, -1.0f, 1.0f);

	debugTextTexture.SetData((uint8_t*)debugTextData);
	debugTextTexture.Bind(0);

	debugTextShader.Bind();
	debugTextShader.SetUniform(debugTextUniformTexture, 0);
	debugTextShader.SetUniform(debugTextUniformProjection, ortho);

	// TODO: вернуть стейты

	glDisable(GL_DEPTH_TEST);
	//glDisable(GL_CULL_FACE);
	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	debugTextVao.Draw();
	glDisable(GL_BLEND);
	glEnable(GL_DEPTH_TEST);
}
//-----------------------------------------------------------------------------
bool DebugText::Init()
{
	constexpr const char* vertexShaderText = R"(
#version 330 core

layout(location = 0) in vec2 in_position;
layout(location = 1) in vec2 in_uv;

out vec2 uv;

uniform mat4 u_projection;

void main() 
{
  gl_Position = u_projection * vec4(in_position.xy, 0.0f, 1.0f);
  uv = in_uv;
}
)";

	constexpr const char* fragmentShaderText = R"(
#version 330 core

in vec2 uv;

out vec4 color;

uniform sampler2D u_texture;

void main()
{
  color = texture(u_texture, vec2(uv.x, uv.y)).rgba;
}
)";

	// load shader
	if( !debugTextShader.CreateFromMemories(vertexShaderText, fragmentShaderText) )
		return false;
	debugTextUniformTexture = debugTextShader.GetUniformLocation("u_texture");
	debugTextUniformProjection = debugTextShader.GetUniformLocation("u_projection");

	// gen texture
	Texture2DInfo texInfo;
	texInfo.wrapS     = TextureWrapping::Clamp;
	texInfo.wrapT     = TextureWrapping::Clamp;
	texInfo.mipmap    = false;
	texInfo.magFilter = TextureMagFilter::Linear;
	texInfo.minFilter = TextureMinFilter::Linear;

	Texture2DCreateInfo createInfo;
	createInfo.width     = DEBUG_WIDTH;
	createInfo.height    = DEBUG_HEIGHT;
	createInfo.format    = TexelsFormat::RGBA_U8;
	createInfo.pixelData = nullptr;
	if( !debugTextTexture.Create(createInfo, texInfo) )
		return false;

	float w = DEBUG_WIDTH;
	float h = DEBUG_HEIGHT;
	float u0 = 0.0f, v0 = 0.0f;
	float u1 = 1.0, v1 = 1.0;
	const float v[] =
	{
		// pos           // uv
		0.0f,     0.0f + h, u0,  v1,
		0.0f,     0.0f,     u0,  v0,
		0.0f + w, 0.0f,     u1,  v0,
		0.0f,     0.0f + h, u0,  v1,
		0.0f + w, 0.0f,     u1,  v0,
		0.0f + w, 0.0f + h, u1,  v1
	};
	if( !debugTextVbo.Create(RenderResourceUsage::Static, 6, 4 * sizeof(float), v) )
		return false;
	if( !debugTextVao.Create(&debugTextVbo, nullptr, &debugTextShader) )
		return false;

	debugTextlen = DEBUG_FONT_WIDTH * DEBUG_FONT_HEIGHT;
	debugTextlen *= DEBUG_WIDTH * DEBUG_HEIGHT;

	debugTextData = new uint32_t[debugTextlen];
	memset(debugTextData, 0, sizeof(uint32_t) * debugTextlen);

	return true;
}
//-----------------------------------------------------------------------------
void DebugText::Close()
{
	if( debugTextData )
	{
		delete[] debugTextData;
		debugTextData = nullptr;

		debugTextVbo.Destroy();
		debugTextVao.Destroy();
		debugTextTexture.Destroy();
		debugTextShader.Destroy();
	}
}
//-----------------------------------------------------------------------------